---
interface PipelineStep {
  shortLabel: string;
  title: string;
  description: string;
  focuses: Array<{ x: number; y: number; w: number; h: number }>;
}

interface Props {
  image: ImageMetadata;
  labels: string[];
}

const { image, labels } = Astro.props;

const steps: PipelineStep[] = [
  {
    shortLabel: "Conditioning Inputs",
    title: "Step 1: Build Joint Conditioning",
    description:
      "The noised latent is conditioned with printed-CDP spatial features and printer-identity text features to expose both local texture and class semantics.",
    focuses: [
      { x: 0.08, y: 0.08, w: 15.78, h: 21.0 },
      { x: 16.37, y: 15.48, w: 15.31, h: 16.77 },
    ],
  },
  {
    shortLabel: "Noise Prediction",
    title: "Step 2: Class-Conditioned Noise Prediction",
    description:
      "For each candidate class, the diffusion backbone predicts reconstruction noise conditioned on template latent, printed signal, and class context.",
    focuses: [{ x: 37.75, y: 21.23, w: 36.5, h: 23.86 }],
  },
  {
    shortLabel: "Class-Wise Error",
    title: "Step 3: Compare Reconstruction Errors",
    description:
      "The model computes an error value per class and chooses the class with minimum denoising loss as the most likely source printer.",
    focuses: [{ x: 16.45, y: 60.9, w: 51.1, h: 12.1 }],
  },
  {
    shortLabel: "Authentication",
    title: "Step 4: Decision Rule",
    description:
      "Authentication succeeds only if the predicted class matches the expected authentic printer; otherwise the sample is flagged as counterfeit.",
    focuses: [{ x: 72.1, y: 43.05, w: 27.91, h: 46.9 }],
  },
];

const authenticLabels = labels.filter((label) => !label.includes("_"));
const expectedOptions = authenticLabels.length > 0 ? authenticLabels : labels;
const defaultExpected = expectedOptions[0] ?? "HP55";
const defaultPredicted = labels[0] ?? defaultExpected;
---

<div class="not-prose full-bleed px-6">
  <section
    class="pipeline-explorer mx-auto max-w-[74rem]"
    data-pipeline-root
    data-steps={JSON.stringify(steps)}
    data-labels={JSON.stringify(labels)}
  >
    <div class="pipeline-header">
      <h4>Interactive Figure 2 Walkthrough</h4>
      <p>
        Click through the pipeline stages to highlight where each operation
        happens in the architecture.
      </p>
    </div>

    <div class="pipeline-layout">
      <div class="pipeline-diagram-panel">
        <div class="pipeline-image-frame">
          <img
            src={image.src}
            width={image.width}
            height={image.height}
            alt="Interactive Figure 2: class-conditioned diffusion authentication pipeline"
            loading="lazy"
          />
          <div class="pipeline-focus-layer" data-focus-layer></div>
        </div>
        <p class="pipeline-diagram-hint">
          Highlight box follows the selected step.
        </p>
      </div>

      <div class="pipeline-stepper-panel">
        <div class="pipeline-step-buttons">
          {
            steps.map((step, index) => (
              <button
                type="button"
                class={`pipeline-step-button ${index === 0 ? "is-active" : ""}`}
                data-step-button={index}
                aria-pressed={index === 0 ? "true" : "false"}
              >
                <span class="pipeline-step-index">{index + 1}</span>
                <span class="pipeline-step-short">{step.shortLabel}</span>
              </button>
            ))
          }
        </div>
        <div class="pipeline-step-detail">
          <p class="pipeline-step-kicker" data-step-kicker>Step 1</p>
          <h5 data-step-title>{steps[0]?.title}</h5>
          <p data-step-description>{steps[0]?.description}</p>
        </div>
      </div>
    </div>

    <div class="pipeline-simulator">
      <div class="pipeline-simulator-header">
        <h4>Authentication Strategy Simulator</h4>
        <p>
          Simulates the final policy:
          authenticate only when predicted class equals expected authentic
          printer.
        </p>
      </div>

      <div class="pipeline-simulator-controls">
        <label>
          Expected authentic printer
          <select data-expected-select>
            {expectedOptions.map((label) => (
              <option value={label} selected={label === defaultExpected}>
                {label}
              </option>
            ))}
          </select>
        </label>
        <label>
          Predicted class
          <select data-predicted-select>
            {labels.map((label, index) => (
              <option value={label} selected={index === 0}>
                {label}
              </option>
            ))}
          </select>
        </label>
      </div>

      <div class="pipeline-simulator-body">
        <div class="pipeline-strategy-card">
          <p class="pipeline-strategy-kicker">Rule Logic</p>
          <ol class="pipeline-strategy-steps">
            <li>Select expected authentic printer label.</li>
            <li>Use model output as predicted class label.</li>
            <li>Accept only if labels match exactly.</li>
          </ol>
          <p class="pipeline-strategy-equation" data-strategy-equation>
            {defaultPredicted} == {defaultExpected}
          </p>
          <p class="pipeline-strategy-outcome" data-strategy-outcome>
            Match -> Authentic
          </p>
        </div>

        <div class="pipeline-decision-card">
          <p class="pipeline-decision-kicker">Decision</p>
          <p class="pipeline-decision-state" data-decision-state>
            Counterfeit
          </p>
          <p class="pipeline-decision-line">
            Predicted class:
            <strong data-predicted-class>{defaultPredicted}</strong>
          </p>
          <p class="pipeline-decision-line">
            Expected class:
            <strong data-expected-class>{defaultExpected}</strong>
          </p>
          <p class="pipeline-decision-reason" data-decision-reason>
            Predicted class does not match expected printer.
          </p>
        </div>
      </div>
    </div>
  </section>
</div>

<script is:inline>
  (() => {
    const roots = document.querySelectorAll("[data-pipeline-root]");
    roots.forEach((root) => {
      const parseJSON = (attributeName, fallback) => {
        const raw = root.getAttribute(attributeName);
        if (!raw) return fallback;
        try {
          return JSON.parse(raw);
        } catch {
          return fallback;
        }
      };

      const steps = parseJSON("data-steps", []);
      const focusLayer = root.querySelector("[data-focus-layer]");
      const stepButtons = Array.from(root.querySelectorAll("[data-step-button]"));
      const stepKicker = root.querySelector("[data-step-kicker]");
      const stepTitle = root.querySelector("[data-step-title]");
      const stepDescription = root.querySelector("[data-step-description]");

      const expectedSelect = root.querySelector("[data-expected-select]");
      const predictedSelect = root.querySelector("[data-predicted-select]");
      const predictedClass = root.querySelector("[data-predicted-class]");
      const expectedClass = root.querySelector("[data-expected-class]");
      const decisionState = root.querySelector("[data-decision-state]");
      const decisionReason = root.querySelector("[data-decision-reason]");
      const strategyEquation = root.querySelector("[data-strategy-equation]");
      const strategyOutcome = root.querySelector("[data-strategy-outcome]");

      const setStep = (index) => {
        const step = steps[index] || steps[0];
        if (!step) return;

        stepButtons.forEach((button, buttonIndex) => {
          const isActive = buttonIndex === index;
          button.classList.toggle("is-active", isActive);
          button.setAttribute("aria-pressed", isActive ? "true" : "false");
        });

        if (focusLayer) {
          focusLayer.innerHTML = "";
          const focuses = Array.isArray(step.focuses) ? step.focuses : [];
          focuses.forEach((focus) => {
            const box = document.createElement("div");
            box.className = "pipeline-focus-box";
            box.style.left = `${focus.x}%`;
            box.style.top = `${focus.y}%`;
            box.style.width = `${focus.w}%`;
            box.style.height = `${focus.h}%`;
            focusLayer.appendChild(box);
          });
        }

        if (stepKicker) stepKicker.textContent = `Step ${index + 1}`;
        if (stepTitle) stepTitle.textContent = step.title;
        if (stepDescription) stepDescription.textContent = step.description;
      };

      stepButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const index = Number(button.getAttribute("data-step-button") ?? "0");
          setStep(Number.isNaN(index) ? 0 : index);
        });
      });

      const runSimulation = () => {
        if (!expectedSelect || !predictedSelect) return;
        const expected = expectedSelect.value;
        const predicted = predictedSelect.value;
        const isAuthentic = predicted === expected;

        if (predictedClass) predictedClass.textContent = predicted;
        if (expectedClass) expectedClass.textContent = expected;

        if (strategyEquation) {
          strategyEquation.textContent = `${predicted} ${isAuthentic ? "==" : "!="} ${expected}`;
        }
        if (strategyOutcome) {
          strategyOutcome.textContent = isAuthentic
            ? "Match -> Authentic"
            : "Mismatch -> Counterfeit";
        }

        if (decisionState) {
          decisionState.textContent = isAuthentic ? "Authentic" : "Counterfeit";
          decisionState.setAttribute("data-state", isAuthentic ? "authentic" : "counterfeit");
        }

        if (decisionReason) {
          decisionReason.textContent = isAuthentic
            ? "Predicted class matches expected printer."
            : "Predicted class does not match expected printer.";
        }
      };

      if (expectedSelect) {
        expectedSelect.addEventListener("change", runSimulation);
      }
      if (predictedSelect) {
        predictedSelect.addEventListener("change", runSimulation);
      }

      setStep(0);
      runSimulation();
    });
  })();
</script>
